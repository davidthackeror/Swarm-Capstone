Index: src/Drone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.awt.*;\r\nimport java.util.LinkedList;\r\nimport java.util.Random;\r\n/**\r\n * Project: Swarm Capstone\r\n * : General category and attributes of the drone sub-classes\r\n * @author David Thacker\r\n * Date: 21 Jan 21\r\n * Class: Capstone\r\n */\r\n\r\npublic abstract class Drone {\r\n    private String name;\r\n    /**\r\n     * the random seed variable\r\n     */\r\n    Random rand = new Random();\r\n\r\n    /**\r\n     * the attributes of an archer (health, min and max attack, min and max speed, min and max courage, size, and range\r\n     */\r\n    static int[] DJIStats = new int[10];\r\n\r\n    /**\r\n     * how far a warrior can attack from\r\n     */\r\n    private int range;\r\n    /**\r\n     * is the warrior supposed to be moving\r\n     */\r\n    private boolean isMoving;\r\n    /**\r\n     * is the warrior alive\r\n     */\r\n    private boolean isAlive;\r\n    /**\r\n     * the warriors x position\r\n     */\r\n    private int xPos;\r\n    /**\r\n     * the warriors y position\r\n     */\r\n    private int yPos;\r\n    /**\r\n     * the warriors z position\r\n     */\r\n    private int zPos;\r\n    /**\r\n     * the warriors pos achieved\r\n     */\r\n    private int posAchieved;\r\n    /**\r\n     * the warriors total health at any given point\r\n     */\r\n    private int health;\r\n    /**\r\n     * the warriors total attack\r\n     */\r\n    private int attack;\r\n    /**\r\n     * how unlikely they are to run away from a battle\r\n     */\r\n    private int courage;\r\n    /**\r\n     * the speed at which the warrior can move across the graphics plain\r\n     */\r\n    private int speed;\r\n    /**\r\n     * the size of the circle drawn to represent the warrior\r\n     */\r\n    private int size;\r\n    /**\r\n     * the color of the warriors alliance (individually assigned for creativity later)\r\n     */\r\n    private Color color;\r\n    /**\r\n     * the x firing coordinate of target drone\r\n     */\r\n    private int fireX;\r\n    /**\r\n     * the y firing coordinate of target drone\r\n     */\r\n    private int fireY;\r\n    /**\r\n     * the z firing coordinate of target drone\r\n     */\r\n    private int fireZ;\r\n    /**\r\n     * boolean to indicate if weapons on drone are armed\r\n     */\r\n    private boolean isFiring;\r\n    //TODO: Probably a better way to do this\r\n    /**\r\n     * linkedList containing x position of the drone over each tick\r\n     */\r\n    LinkedList<Integer> positionXArray = new LinkedList<Integer>();\r\n    /**\r\n     * linkedList containing y position of the drone over each tick\r\n     */\r\n    LinkedList<Integer> positionYArray = new LinkedList<Integer>();\r\n    /**\r\n     * linkedList containing z position of the drone over each tick\r\n     */\r\n    LinkedList<Integer> positionZArray = new LinkedList<Integer>();\r\n\r\n    private int[] minArray = new int[3];\r\n\r\n    Drone() {\r\n        this.xPos = 0;\r\n        this.yPos = 0;\r\n        this.zPos = 0;\r\n        this.posAchieved = 0;\r\n        this.health = 0;\r\n        this.attack = 0;\r\n        this.courage = 0;\r\n        this.speed = 0;\r\n        this.size = 0;\r\n        this.isFiring = false;\r\n        this.isMoving = true;\r\n        this.isAlive = true;\r\n    }\r\n\r\n    public Drone(int xPos, int yPos, int zPos, int posAchieved, int health, int attack, int courage, int speed, int size, Color color, boolean isMoving, boolean isAlive, String name){\r\n        this.xPos = xPos;\r\n        this.yPos = yPos;\r\n        this.zPos = zPos;\r\n        this.posAchieved = posAchieved;\r\n        this.health = health;\r\n        this.attack = attack;\r\n        this.courage = courage;\r\n        this.speed = speed;\r\n        this.size = size;\r\n        this.color = color;\r\n        this.isFiring = false;\r\n        this.isMoving = isMoving;\r\n        this.isAlive = isAlive;\r\n        this.name = name;\r\n\r\n    }\r\n\r\n    //begin abstract methods\r\n\r\n\r\n    /**\r\n     * Moves the warrior in the direction of the target x and y in proportion to it's speed\r\n     *\r\n     * @param xTarget The x coordinate of the target enemy soldier\r\n     * @param yTarget The y coordinate of the target enemy soldier\r\n     * @param zTarget The y coordinate of the target enemy soldier\r\n     */\r\n    public abstract void move(int xTarget, int yTarget, int zTarget);\r\n\r\n    /**\r\n     * puts the selected warrior on the screen with its assigned x, y, size, and color\r\n     *\r\n     * @param g The graphics window to be written to\r\n     */\r\n    public abstract void draw(Graphics2D g);\r\n\r\n    /**\r\n     * overrided method to draw lasers from drones\r\n     * @param g the graphics window to be written to\r\n     */\r\n    public abstract void drawFire(Graphics2D g);\r\n\r\n    /**\r\n     * overrided method to draw explosion upon drone death\r\n     * @param g the graphics window to be written to\r\n     */\r\n    public abstract void drawExplosion(Graphics2D g);\r\n\r\n    /**\r\n     * adds the current x and y pos of the drone on each tick to a linked list\r\n     */\r\n    public void locationTracking(){\r\n        positionXArray.add(xPos);\r\n        positionYArray.add(yPos);\r\n        positionZArray.add(zPos);\r\n    }\r\n\r\n    //TODO: Investigate .drawPolyLine\r\n\r\n    /**\r\n     * takes in the linkedList inherent to each drone and draws a line of ovals marking its location over time\r\n     * @param g the graphics panel to draw on\r\n     */\r\n    public void drawTracking(Graphics2D g){\r\n        //X and Y are assigned at the same time\r\n        for (int i = 0; i < positionYArray.size(); i++) {\r\n            g.setColor(this.color);\r\n            //can mess with width and height to get thicker line, should probably use .drawPolyLine\r\n            g.drawOval(positionXArray.get(i), positionYArray.get(i), 5 , 5);\r\n        }\r\n    }\r\n\r\n    //TODO: CHECK Z ABOVE\r\n\r\n    //begin non abstract methods (getter and setter methods)\r\n\r\n    /**\r\n     * gets the x position of an object\r\n     *\r\n     * @return the x position of the object\r\n     */\r\n    int getxPos() {\r\n        return xPos;\r\n    }\r\n\r\n    /**\r\n     * sets the x position of an object\r\n     *\r\n     * @param xPos the x position to be inserted into the object\r\n     */\r\n    void setxPos(int xPos) {\r\n        this.xPos = xPos;\r\n    }\r\n\r\n    /**\r\n     * gets the y position of an object\r\n     * @return the y position of the object\r\n     */\r\n    int getyPos() {\r\n        return yPos;\r\n    }\r\n\r\n    /**\r\n     * sets the y position of an object\r\n     *\r\n     * @param yPos the y position to be inserted into the object\r\n     */\r\n    void setyPos(int yPos) {\r\n        this.yPos = yPos;\r\n    }\r\n\r\n    /**\r\n     * gets the z position of an object\r\n     * @return the z position of the object\r\n     */\r\n    int getzPos() {\r\n        return zPos;\r\n    }\r\n\r\n    /**\r\n     * sets the z position of an object\r\n     *\r\n     * @param zPos the z position to be inserted into the object\r\n     */\r\n    void setzPos(int zPos) {\r\n        this.zPos = zPos;\r\n    }\r\n\r\n    /**\r\n     * gets the health of the object\r\n     * @return the health of the object\r\n     */\r\n    int getHealth() {\r\n        return health;\r\n    }\r\n\r\n    /**\r\n     * set the health of an object\r\n     *\r\n     * @param health the health parameter to be inserted into the object\r\n     */\r\n    void setHealth(int health) {\r\n        this.health = health;\r\n    }\r\n\r\n    /**\r\n     * gets the attack of the object\r\n     * @return the attack of the object\r\n     */\r\n    int getAttack() {\r\n        return attack;\r\n    }\r\n\r\n    /**\r\n     * set the attack of an object\r\n     * @param attack the attack parameter to be inserted into the object\r\n     */\r\n    void setAttack(int attack) {\r\n        this.attack = attack;\r\n    }\r\n\r\n    /**\r\n     * set the courage of an object\r\n     *\r\n     * @param courage the courage parameter to be inserted into the object\r\n     */\r\n    void setCourage(int courage) {\r\n        this.courage = courage;\r\n    }\r\n\r\n    /**\r\n     * gets the speed of the object\r\n     * @return the speed of the object\r\n     */\r\n    int getSpeed() {\r\n        return speed;\r\n    }\r\n\r\n    /**\r\n     * set the speed of an object\r\n     * @param speed the speed parameter to be inserted into the object\r\n     */\r\n    void setSpeed(int speed) {\r\n        this.speed = speed;\r\n    }\r\n\r\n    /**\r\n     * gets the size of the object\r\n     * @return the size of the object\r\n     */\r\n    int getSize() {\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * set the size of an object\r\n     * @param size the size parameter to be inserted into the object\r\n     */\r\n    void setSize(int size) {\r\n        this.size = size;\r\n    }\r\n\r\n    /**\r\n     * gets the range of the object\r\n     * @return the range of the object\r\n     */\r\n    int getRange() {\r\n        return this.range;\r\n    }\r\n\r\n    /**\r\n     * set the range of an object\r\n     * @param range the range parameter to be inserted into the object\r\n     */\r\n    void setRange(int range) {\r\n        this.range = range;\r\n    }\r\n\r\n    /**\r\n     * set the color of an object\r\n     * @param color the color parameter to be inserted into the object\r\n     */\r\n    void setColor(Color color) {\r\n        this.color = color;\r\n    }\r\n\r\n    /**\r\n     * gets the color the object\r\n     * @return the color of the object\r\n     */\r\n    Color getColor() {\r\n        return this.color;\r\n    }\r\n\r\n    /**\r\n     * sees if the object is moving\r\n     * @return the moving status of the object\r\n     */\r\n    boolean isMoving() {\r\n        return isMoving;\r\n    }\r\n\r\n    /**\r\n     * sets the objects moving status\r\n     * @param moving the true or false of whether the object is moving or not\r\n     */\r\n    void setMoving(boolean moving) {\r\n        isMoving = moving;\r\n    }\r\n\r\n    /**\r\n     * sees if the object is alive\r\n     * @return the life status of the object\r\n     */\r\n    boolean isAlive() {\r\n        return isAlive;\r\n    }\r\n\r\n    /**\r\n     * sees if the object is alive\r\n     * @param alive the boolean of whether the object is alive or not\r\n     */\r\n    void setAlive(boolean alive) {\r\n        isAlive = alive;\r\n    }\r\n\r\n    /**\r\n     * sets the location the drone is to fire upon, variable used to fire laser\r\n     * @param x x location of target drone\r\n     */\r\n    void setFireX(int x){ fireX = x;}\r\n\r\n    /**\r\n     * gets the location the drone is to fire upon, variable used to fire laser\r\n     * @return x location of target drone\r\n     */\r\n    int getFireX(){return fireX;}\r\n\r\n    /**\r\n     * sets the location the drone is to fire upon, variable used to fire laser\r\n     * @param y location of the target drone\r\n     */\r\n    void setFireY(int y){ fireY = y;}\r\n\r\n    /**\r\n     * gets the location the drone is to fire upon, variable used to fire laser\r\n     * @return location of the target drone\r\n     */\r\n    int getFireY(){return fireY;}\r\n\r\n    /**\r\n     * sets the location the drone is to fire upon, variable used to fire laser\r\n     * @param z location of the target drone\r\n     */\r\n    void setFireZ(int z){ fireZ = z;}\r\n\r\n    /**\r\n     * gets the location the drone is to fire upon, variable used to fire laser\r\n     * @return location of the target drone\r\n     */\r\n    int getFireZ(){return fireZ;}\r\n\r\n    /**\r\n     * fetches the unique ID of the specific drone in question\r\n     * @return name\r\n     */\r\n    String getName() { return name; }\r\n\r\n    /**\r\n     * Each drone is identified by a name for ease of tracking\r\n     * @param b the name of the drone\r\n     */\r\n    void setName(String b){name = b;}\r\n\r\n    public int[] getMinArray() {\r\n        return minArray;\r\n    }\r\n\r\n    public void setMinArray(int[] minArray) {\r\n        this.minArray = minArray;\r\n    }\r\n\r\n    /**\r\n     * determines if a drone is actively firing their laser\r\n     * @return a boolean indicating whether the laser is engaged\r\n     */\r\n    public boolean isFiring() {\r\n        return isFiring;\r\n    }\r\n\r\n    /**\r\n     * switches the drone into weapons mode, indicated preparedness to fire laser\r\n     * @param firing a boolean indicating weapons ON or OFF\r\n     */\r\n    public void setFiring(boolean firing) {\r\n        isFiring = firing;\r\n    }\r\n\r\n    /**\r\n     * gets the speed of the object\r\n     * @return the speed of the object\r\n     */\r\n    int getposAchieved() {\r\n        return posAchieved;\r\n    }\r\n\r\n    /**\r\n     * set the speed of an object\r\n     */\r\n    void setposAchieved(int posAchieved) {\r\n        this.posAchieved = posAchieved;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Drone.java b/src/Drone.java
--- a/src/Drone.java	(revision 2cb12ad41317acdf442dae3ac5e4c279f041e10e)
+++ b/src/Drone.java	(date 1618943719940)
@@ -17,7 +17,7 @@
     Random rand = new Random();
 
     /**
-     * the attributes of an archer (health, min and max attack, min and max speed, min and max courage, size, and range
+     * the attributes of a drone (health, min and max attack, min and max speed, min and max courage, size, and range
      */
     static int[] DJIStats = new int[10];
 
Index: src/Battle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.sound.sampled.*;\r\nimport java.awt.*;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\nimport java.math.*;\r\n\r\n\r\n/**\r\n * Project: Swarm Capstone\r\n * : Controls execution of the battle\r\n *\r\n * @author David Thacker\r\n * Date: 21 Jan 21\r\n * Class: Capstone\r\n */\r\nclass Battle {\r\n    /**\r\n     * the relative path to the death sound\r\n     */\r\n    static String fileName = \"Explosion.wav\";\r\n\r\n    /**\r\n     * the armies arraylist containing all armys and therefore warriors\r\n     */\r\n    private static ArrayList<Swarm> swarms = new ArrayList<>();\r\n\r\n    //TODO: Placeholder for a gui assignment of the # of drones.\r\n    public static int numDrones = 30;\r\n\r\n    private static int collisionRadius = 300;\r\n    //TODO: do drone attributes in a different location\r\n    /**\r\n     * sets the attributes of the drones, should be refactored\r\n     *\r\n     * @param array stores attributes of the drones in an array\r\n     */\r\n    static void setDroneArrayAttributes(int[] array) {\r\n        array[0] = 50;//health\r\n        array[1] = 10;//minAttack\r\n        array[2] = 20;//maxAttack\r\n        array[3] = 4;//minSpeed\r\n        array[4] = 6;//maxSpeed\r\n        array[5] = 10;//minCourage\r\n        array[6] = 30;//maxCourage\r\n        array[7] = 10;//Size\r\n        array[8] = 200;//Range\r\n\r\n    }\r\n\r\n    Battle() {\r\n        //TODO: Change ALgo Num\r\n        addSwarm(0, \"allies\", swarms, 0);\r\n        addSwarm(1, \"axis\", swarms, 0);\r\n\r\n    }\r\n\r\n    /**\r\n     * adds an army with predetermined warrior allotments and the following attributes\r\n     *\r\n     * @param allianceNumber the number the army associates its alliance with\r\n     * @param name           the name of that army\r\n     * @param swarms         the arraylist containing all armys\r\n     */\r\n    static void addSwarm(int allianceNumber, String name, ArrayList<Swarm> swarms, int algoNum) {\r\n        swarms.add(armySize(allianceNumber, name, algoNum));\r\n    }\r\n\r\n    static ArrayList<Swarm> getSwarms(){\r\n        return swarms;\r\n    }\r\n    /**\r\n     * calls drawWarriors while also passing the armies array contained within\r\n     * @param g the graphics panel to be drawn on\r\n     */\r\n    static void drawSwarm(Graphics g) {\r\n        Battle.drawDrone((Graphics2D) g, swarms);\r\n    }\r\n\r\n    /**\r\n     * detectEnemy() uses the Vector330Class to determine the enemy closest to a selected warrior\r\n     * and store the closest warrior, its magnitude, and army in the array\r\n     *\r\n     * @param attacker  the specific warrior to detect the closest enemy for\r\n     * @param defenders the entire enemy army\r\n     */\r\n    private static void detectEnemy(Drone attacker, Swarm defenders, int[] minArray) {\r\n        int index = -1;\r\n        int minimumDistance = 1000;\r\n        Vector330Class calcVector = new Vector330Class();\r\n        //for every defender in the army check to see their distance\r\n        for (int j = 0; j < defenders.drones.size(); j++) {\r\n            //check to see if that selected soldier is alive\r\n            if (defenders.drones.get(j).isAlive()) {\r\n                //calculate a vector for the difference in positions between the warrior and the selected defender\r\n                calcVector.setX(defenders.drones.get(j).getxPos() - attacker.getxPos());\r\n                calcVector.setY(defenders.drones.get(j).getyPos() - attacker.getyPos());\r\n                calcVector.setY(defenders.drones.get(j).getzPos() - attacker.getzPos()); //Check this line\r\n                //check to see if that magnitude is the smallest yet\r\n                if (calcVector.magnitude() < minArray[1]) {\r\n                    minArray[2] = defenders.getAllianceNum();\r\n                    minArray[1] = (int) calcVector.magnitude();\r\n                    minArray[0] = j;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * outOfBounds() detects if a specific warrior is out of the bounds of the graphics window\r\n     *\r\n     * @param attacker the warrior to check its position\r\n     * @return a true if out of bounds\r\n     */\r\n\r\n    static boolean outOfBounds(Drone attacker) {\r\n        return attacker.getxPos() > Main.SIZE * Main.ratioX || attacker.getyPos() > Main.SIZE * Main.ratioY || attacker.getxPos() < 0 || attacker.getyPos() < 0;\r\n    }\r\n\r\n    /**\r\n     * moveWarriors() will move all warriors of the respective armies closer to closest enemy detected\r\n     *\r\n     */\r\n    static void moveDrones()\r\n    {\r\n        Controller.Cont(swarms);\r\n    }\r\n\r\n    static int[] enemyDetection(Swarm Attackers, int i){\r\n        int[] coords = new int[3];\r\n        int[] soldierArray = Attackers.drones.get(i).getMinArray();\r\n        int index = soldierArray[0];\r\n        //if detectEnemy comes back with a -1 then there are no more alive enemies\r\n        try\r\n        {\r\n            if (soldierArray[0] == -1)\r\n            {\r\n                throw new Exception(\"That does not exist.\");\r\n            }\r\n        }\r\n        catch (Exception ignored)\r\n        {\r\n        }\r\n        Swarm axis = swarms.get(soldierArray[2]);\r\n        coords[0] = axis.drones.get(index).getxPos();\r\n        coords[1] = axis.drones.get(index).getyPos();\r\n        coords[2] = axis.drones.get(index).getzPos();\r\n        //System.out.println(\"Target; \" + coords[0] + \" , \" + coords[1] + \" , \" + coords[2] );\r\n        return coords;\r\n    }\r\n\r\n    static int[] highestEnemyDetection(Swarm Attackers){\r\n        int[] coords = new int[3];\r\n        int saveHighest = 0;\r\n        int i;\r\n        Swarm axis = null;\r\n        int team = Attackers.getAllianceNum();\r\n        if (team == 1){\r\n            axis = swarms.get(0); //blue teams algo\r\n        } else if (team == 0){\r\n            axis = swarms.get(1); //red teams algo\r\n        }\r\n        \r\n        for (i = 0; i < axis.drones.size() - 1; i++){\r\n            if (axis.drones.get(saveHighest).getzPos() < axis.drones.get(i).getzPos()){\r\n                saveHighest = i;\r\n            }\r\n        }\r\n        coords[0] = axis.drones.get(i).getxPos();\r\n        coords[1] = axis.drones.get(i).getyPos();\r\n        coords[2] = axis.drones.get(i).getzPos();\r\n        //System.out.println(\"Target; \" + coords[0] + \" , \" + coords[1] + \" , \" + coords[2] );\r\n        return coords;\r\n    }\r\n\r\n    static int[] flankLeft(Swarm Attackers, int i){\r\n        int[] coords = new int[3];\r\n        int[] soldierArray = Attackers.drones.get(i).getMinArray();\r\n        int index = soldierArray[0];\r\n        //if detectEnemy comes back with a -1 then there are no more alive enemies\r\n        try\r\n        {\r\n            if (soldierArray[0] == -1)\r\n            {\r\n                throw new Exception(\"That does not exist.\");\r\n            }\r\n        }\r\n        catch (Exception ignored)\r\n        {\r\n        }\r\n        Swarm axis = swarms.get(soldierArray[2]);\r\n\r\n        if(Attackers.drones.get(i).getposAchieved() == 0 && Attackers.getAllianceNum() == 0) {\r\n            //Attackers.drones.get(i).setSpeed(Attackers.drones.get(i).getSpeed());\r\n            coords[0] = ((Main.SIZE * Main.ratioX) / 2) + 300;\r\n            coords[1] = 50;\r\n            coords[2] = Attackers.drones.get(i).getzPos(); //TODO FIX Z STUFF\r\n        } else if (Attackers.drones.get(i).getposAchieved() == 0 && Attackers.getAllianceNum() == 1) {\r\n            coords[0] = ((Main.SIZE * Main.ratioX) / 2) - 300;\r\n            coords[1] = (Main.SIZE*Main.ratioY - 50) ;\r\n            coords[2] = Attackers.drones.get(i).getzPos(); //TODO FIX Z STUFF\r\n        }\r\n\r\n        //System.out.println(\"Target; \" + coords[0] + \" , \" + coords[1] + \" , \" + coords[2] );\r\n        return coords;\r\n    }\r\n\r\n\r\n    static boolean checkCollision(Swarm friendlies, Drone avoidance){\r\n        int radiusSquared = collisionRadius * collisionRadius;\r\n        for (int i = 0; i < friendlies.drones.size(); i++) {\r\n            if(friendlies.drones.get(i).isAlive()){\r\n                Drone comparison = friendlies.drones.get(i);\r\n                int firstHalf = radiusCalculation(avoidance.getxPos(), avoidance.getyPos(), comparison.getxPos(), comparison.getyPos());\r\n                if(firstHalf < radiusSquared){\r\n                    //System.out.println(\"Collision detected between \" + avoidance.getName() + \" and \" + comparison.getName());\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    static int radiusCalculation(int x1, int y1, int x2, int y2){\r\n        int xCalc = (x1 - x2) * (x1 - x2);\r\n        int yCalc = (y1 - y2) * (y1 - y2);\r\n        return xCalc + yCalc;\r\n    }\r\n\r\n\r\n    /**\r\n     * drawWarriors() puts the alive warriors of each army on screen in accordance with their x and y positions\r\n     *\r\n     * @param g      the graphics window to draw to\r\n     * @param armies a array list containing all the armies in play\r\n     */\r\n    private static void drawDrone(Graphics2D g, ArrayList<Swarm> armies) {\r\n\r\n        for (Swarm swarm : armies) {\r\n            for (int i = 0; i < swarm.drones.size(); i++) {\r\n                if (swarm.drones.get(i).isAlive()) {\r\n                    swarm.drones.get(i).draw(g);\r\n                    swarm.drones.get(i).drawFire(g);\r\n                    swarm.drones.get(i).locationTracking();\r\n                    swarm.drones.get(i).drawTracking(g);\r\n                }\r\n                else{\r\n                    swarm.drones.get(i).drawExplosion(g);\r\n                }\r\n                swarm.drones.get(i).locationTracking();\r\n                swarm.drones.get(i).drawTracking(g);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * warriorDamage() goes through all armies in play and deals damage to those alive\r\n     *\r\n     * @param armies a array list containing all the armies in play\r\n     */\r\n     static void droneDamage(ArrayList<Swarm> armies) {\r\n        Random rand = new Random();\r\n        for (Object army : armies) {\r\n            Swarm Attackers = (Swarm) army;\r\n            for (int i = 0; i < Attackers.drones.size(); i++) {\r\n                if (Attackers.drones.get(i).isAlive()) {\r\n                    int[] intArray = new int[4];\r\n                    intArray[0] = -1; //index of lowest\r\n                    intArray[1] = 1000; //magnitude of lowest\r\n                    intArray[2] = -1; //army of lowest\r\n                    for (Object o : armies) {\r\n                        Swarm enemySwarm = (Swarm) o;\r\n                        if (enemySwarm.getAllianceNum() != Attackers.getAllianceNum()) {\r\n                            detectEnemy(Attackers.drones.get(i), enemySwarm, intArray);\r\n                        }\r\n                    }\r\n                    try {\r\n                        if (intArray[0] == -1) {\r\n                            throw new Exception(\"That does not exist.\");\r\n                        }\r\n                    } catch (Exception e) {\r\n                        break;\r\n                    }\r\n                    Swarm Defenders = (Swarm) armies.get(intArray[2]);\r\n\r\n                    //TODO: make this a test case\r\n                    if (magnitude(Attackers.drones.get(i), Defenders, intArray[0]) <= Attackers.drones.get(i).getRange() + Attackers.drones.get(i).getSize() && Defenders.drones.get(intArray[0]).isAlive()) {\r\n                        //determine if attacker has missed the defender\r\n                        if (!(rand.nextInt(100) <= 100 * Attackers.drones.get(i).getAttack() / (Attackers.drones.get(i).getAttack() + Defenders.drones.get(intArray[0]).getAttack()))) {\r\n                            //stop them from moving so that they can shoot or attack\r\n                            Attackers.drones.get(i).setMoving(false);\r\n                            Attackers.drones.get(i).setFireX(Defenders.drones.get(intArray[0]).getxPos());\r\n                            Attackers.drones.get(i).setFireY(Defenders.drones.get(intArray[0]).getyPos());\r\n                            Attackers.drones.get(i).setFiring(true);\r\n\r\n                            //TODO: make test case\r\n                            Defenders.drones.get(intArray[0]).setHealth(Defenders.drones.get(intArray[0]).getHealth() - Attackers.drones.get(i).getAttack()); //removes health\r\n\r\n                            //show how much damage was done\r\n                            //System.out.println(Attackers.drones.get(i).getName() + \" just dealt \" + (Attackers.drones.get(i).getAttack()) + \" damage to \" + Defenders.drones.get(intArray[0]).getName() + \" in army \" + intArray[2]);\r\n\r\n                            if (Defenders.drones.get(intArray[0]).getHealth() <= 0) {\r\n                                playSound();\r\n                                Defenders.drones.get(intArray[0]).setAlive(false);\r\n                                Defenders.drones.get(intArray[0]).setHealth(0);\r\n                                //System.out.println(Attackers.drones.get(i).getName() + \" \" + i + \" just killed \" + Defenders.drones.get(intArray[0]).getName() + \" \" + intArray[0] + \" in army \" + intArray[2]);\r\n                            }\r\n                        } else {\r\n                            //print out a missed message\r\n                            //System.out.println(Attackers.drones.get(i).getName() + \" has just missed \" + Defenders.drones.get(intArray[0]).getName());\r\n                        }\r\n                    } else {\r\n                        Attackers.drones.get(i).setMoving(true);\r\n                    }\r\n                    Attackers.drones.get(i).setMinArray(intArray);\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * plays the minecraft death noise when a soldier is killed\r\n     */\r\n    private static void playSound() {\r\n        //creates a noise when a warrior dies\r\n        try {\r\n            File soundFile = new File(fileName);\r\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(soundFile);\r\n            Clip clip = AudioSystem.getClip();\r\n            clip.open(audioStream);\r\n            clip.start();\r\n        } catch (UnsupportedAudioFileException e) {\r\n            //System.out.println(\"Audio file not supported, make sure its a wav\");\r\n        } catch (IOException e) {\r\n            //System.out.println(\"IO exception\");\r\n        } catch (LineUnavailableException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * magnitude() calculates the distance from a selected soldier to the closest enemy\r\n     *\r\n     * @param soldier  the selected warrior to compare its distance from a selected enemy\r\n     * @param defender an army containing enemy warriors\r\n     * @param index    the location of the closest enemy to the selected warrior\r\n     * @return the distance between a warrior and a selected enemy\r\n     */\r\n    private static double magnitude(Drone soldier, Swarm defender, int index) {\r\n        double distance;\r\n        double deltaZ;\r\n        Vector330Class calcVector = new Vector330Class();\r\n        calcVector.setX(soldier.getxPos() - defender.drones.get(index).getxPos());\r\n        calcVector.setY(soldier.getyPos() - defender.drones.get(index).getyPos());\r\n        deltaZ = Math.abs(soldier.getzPos() - defender.drones.get(index).getzPos());\r\n        distance = Math.sqrt(deltaZ * deltaZ) + (calcVector.magnitude() + calcVector.magnitude());\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * armySize takes in a (currently) class variable and uses that number to set the number of drones in an army\r\n     *\r\n     * @param allianceNumber the identifier of a swarm\r\n     * @param name the name of the swarm\r\n     * @return a new swarm, or collection of drones\r\n     */\r\n    static Swarm armySize(int allianceNumber, String name, int algoNum) {\r\n        if (name.equals(\"null\")) {\r\n            return new Swarm(allianceNumber, 0, name, 0);\r\n\r\n        } else {\r\n            setDroneArrayAttributes(Drone.DJIStats);\r\n\r\n            return new Swarm(allianceNumber, numDrones, name, algoNum);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Battle.java b/src/Battle.java
--- a/src/Battle.java	(revision 2cb12ad41317acdf442dae3ac5e4c279f041e10e)
+++ b/src/Battle.java	(date 1618944572377)
@@ -45,7 +45,7 @@
         array[5] = 10;//minCourage
         array[6] = 30;//maxCourage
         array[7] = 10;//Size
-        array[8] = 200;//Range
+        array[8] = 1;//Range
 
     }
 
@@ -285,7 +285,7 @@
                     Swarm Defenders = (Swarm) armies.get(intArray[2]);
 
                     //TODO: make this a test case
-                    if (magnitude(Attackers.drones.get(i), Defenders, intArray[0]) <= Attackers.drones.get(i).getRange() + Attackers.drones.get(i).getSize() && Defenders.drones.get(intArray[0]).isAlive()) {
+                    if (magnitude(Attackers.drones.get(i), Defenders, intArray[0]) <= (Attackers.drones.get(i).getRange() + Attackers.drones.get(i).getSize() * (Attackers.drones.get(i).getzPos() * .03)) && Defenders.drones.get(intArray[0]).isAlive()) { //determines range of the drones weapons
                         //determine if attacker has missed the defender
                         if (!(rand.nextInt(100) <= 100 * Attackers.drones.get(i).getAttack() / (Attackers.drones.get(i).getAttack() + Defenders.drones.get(intArray[0]).getAttack()))) {
                             //stop them from moving so that they can shoot or attack
Index: src/DJI.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\nimport javax.imageio.ImageIO;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * Project: Swarm Capstone\r\n * : The DJI Drone Sub-Class (fake)\r\n *\r\n * @author David Thacker\r\n * Date: 21 Jan 21\r\n * Class: Capstone\r\n */\r\nclass DJI extends Drone {\r\n\r\n\r\n\r\n    DJI(int minHealth, int maxHealth, int minSpeed, int maxSpeed, int minCourage, int maxCourage, int size, int minAttack, int maxAttack, int range, String name){\r\n        super();\r\n        this.setxPos(1);\r\n        this.setyPos(1);\r\n        this.setzPos(1);\r\n        this.setposAchieved(0);\r\n        this.setHealth(DJIStats[0]);\r\n        this.setAttack(Swarm.getRandomNumberInRange(DJIStats[1], DJIStats[2]));\r\n        this.setSpeed(Swarm.getRandomNumberInRange(DJIStats[3], DJIStats[4]));\r\n        this.setCourage(Swarm.getRandomNumberInRange(DJIStats[5], DJIStats[6]));\r\n        this.setSize(DJIStats[7]);\r\n        this.setRange(DJIStats[8]);\r\n        this.setName(name);\r\n    }\r\n\r\n    /**\r\n     * move() - Moves the warrior in the direction of the target x and y in proportion to it's speed\r\n     *\r\n     * @param xTarget The x coordinate of the target enemy soldier\r\n     * @param yTarget The y coordinate of the target enemy soldier\r\n     * @param zTarget The z coordinate of the target enemy soldier\r\n     */\r\n    @Override\r\n    public void move(int xTarget, int yTarget, int zTarget) {\r\n        //System.out.println(this.getName() + \" targetZ \" + (zTarget - this.getzPos()));\r\n        //System.out.println(this.getName() + \" nonunit: \" + (xTarget- this.getxPos()) + \" \" + (yTarget - this.getyPos()) + \" \" + (zTarget - this.getzPos()));\r\n\r\n        Vector330Class unitVector = new Vector330Class(xTarget- this.getxPos(), yTarget - this.getyPos(), zTarget - this.getzPos());\r\n        Vector330Class unit = unitVector.normalize();\r\n        //System.out.println(this.getName() + \" unit: \" + unit.getX() + \" \" + unit.getY() + \" \" + unit.getZ());\r\n        double xShift = (unit.getX() * this.getSpeed());\r\n        double yShift = (unit.getY() * this.getSpeed());\r\n        double zShift = (unit.getZ() * this.getSpeed());\r\n        this.setxPos((int) (xShift + this.getxPos()));\r\n        this.setyPos((int) (yShift + this.getyPos()));\r\n        this.setzPos((int) (zShift + this.getzPos()));\r\n\r\n    }\r\n\r\n    /**\r\n     * draw() - puts the selected warrior on the screen with its assigned x, y, size, and color\r\n     * @param g The graphics window to be written to\r\n     */\r\n    @Override\r\n    public void draw(Graphics2D g) {\r\n        {\r\n            BufferedImage img = null;\r\n            try {\r\n                String opacityNumber;\r\n                if (this.getzPos() > 0 && this.getzPos() <= Main.CEILING / 20) {\r\n                    opacityNumber = \"5\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 2) {\r\n                    opacityNumber = \"10\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 3) {\r\n                    opacityNumber = \"15\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 4) {\r\n                    opacityNumber = \"20\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 5) {\r\n                    opacityNumber = \"25\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 6) {\r\n                    opacityNumber = \"30\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 7) {\r\n                    opacityNumber = \"35\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 8) {\r\n                    opacityNumber = \"40\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 9) {\r\n                    opacityNumber = \"45\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 10) {\r\n                    opacityNumber = \"50\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 11) {\r\n                    opacityNumber = \"55\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 12) {\r\n                    opacityNumber = \"60\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 13) {\r\n                    opacityNumber = \"65\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 14) {\r\n                    opacityNumber = \"70\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 15) {\r\n                    opacityNumber = \"75\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 16) {\r\n                    opacityNumber = \"80\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 17) {\r\n                    opacityNumber = \"85\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 18) {\r\n                    opacityNumber = \"90\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 19) {\r\n                    opacityNumber = \"95\";\r\n                } else if (this.getzPos() <= (Main.CEILING / 20) * 20) {\r\n                    opacityNumber = \"100\";\r\n                } else {\r\n                    opacityNumber = \"100\";\r\n                }\r\n                img = ImageIO.read(new File(\"drones/drone\" + opacityNumber + \".png\"));\r\n            } catch (IOException ignored) {\r\n            }\r\n\r\n            g.setColor(this.getColor());\r\n            g.drawRect(this.getxPos()-this.getSize(), this.getyPos()-this.getSize(), img.getWidth(), img.getHeight());\r\n            g.drawImage(img, this.getxPos()-this.getSize(), this.getyPos()-this.getSize(), null);\r\n            g.drawString(this.getName(), this.getxPos(), this.getyPos() - 15);\r\n            g.drawString(String.valueOf(this.getzPos()), this.getxPos(), this.getyPos() - 30);\r\n\r\n        }\r\n    }\r\n\r\n    //TODO: check Z above and below\r\n\r\n    /**\r\n     * draws the laser coming from each drone\r\n     * @param g the graphics window to be written to\r\n     */\r\n    @Override\r\n    public void drawFire(Graphics2D g){\r\n        if(this.isFiring()){\r\n            g.drawLine(this.getxPos(), this.getyPos(), this.getFireX(), this.getFireY());\r\n            this.setFiring(false);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * draws the explosion of a drone once it dies, explosion lasts for 10 ticks\r\n     * @param g the graphics window to be written to\r\n     */\r\n    @Override\r\n    public void drawExplosion(Graphics2D g) {\r\n        {\r\n            //as long as drone is dead, and hasn't been dead for forever draw explosion\r\n            if(this.getHealth() <= 0 && this.getHealth() >= -10){ //change the greaterthan or equal to change duration\r\n                BufferedImage img = null;\r\n                try {\r\n                    img = ImageIO.read(new File(\"explosion.png\")); //relative file path\r\n                } catch (IOException ignored) {\r\n                }\r\n\r\n                g.setColor(this.getColor());\r\n                g.drawRect(this.getxPos()-this.getSize(), this.getyPos()-this.getSize(), img.getWidth(), img.getHeight());\r\n                g.drawImage(img, this.getxPos()-this.getSize(), this.getyPos()-this.getSize(), null);\r\n                g.drawString(this.getName(), this.getxPos(), this.getyPos());\r\n                this.setHealth(this.getHealth() - 1);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/DJI.java b/src/DJI.java
--- a/src/DJI.java	(revision 2cb12ad41317acdf442dae3ac5e4c279f041e10e)
+++ b/src/DJI.java	(date 1618943617230)
@@ -17,7 +17,7 @@
 
 
 
-    DJI(int minHealth, int maxHealth, int minSpeed, int maxSpeed, int minCourage, int maxCourage, int size, int minAttack, int maxAttack, int range, String name){
+    DJI(double minHealth, double maxHealth, double minSpeed, double maxSpeed, double minCourage, double maxCourage, double size, double minAttack, double maxAttack, double range, String name){
         super();
         this.setxPos(1);
         this.setyPos(1);
Index: src/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.swing.*;\r\n\r\n/**\r\n * Project: Swarm Capstone\r\n * : The Room Where It Happens\r\n *\r\n * @author David Thacker\r\n * Date: 21 Jan 21\r\n * Class: Capstone\r\n */\r\npublic class Main {\r\n    //determines the size of the graphics display window\r\n    static final int ratioX = 16;\r\n    static final int ratioY = 9;\r\n    static final int SIZE = 75;\r\n    static final int FLOOR = 1000;\r\n    static final int CEILING = 2000;\r\n    //the time to wait between drawing on screen and moving to next tick\r\n    private static final int TIME_STEP = 100;\r\n\r\n    public static void main(String[] args) {\r\n\r\n        //call for preset values or not user selected values for each warrior class\r\n        Battle battle = new Battle();\r\n        BattleGUI battleGUI = new BattleGUI();\r\n        battleGUI.setBattle(battle);\r\n        JFrame jFrame = new JFrame(\"DRONE SWARMING\");\r\n        jFrame.setContentPane(battleGUI.getHello());\r\n        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        jFrame.pack();\r\n        jFrame.setVisible(true);\r\n        AnimationThread animationThread = new AnimationThread(battleGUI.getAnimationArea());\r\n        animationThread.start();\r\n        animationThread.toggleAnimation();\r\n        battleGUI.setAnimationThread(animationThread);\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Main.java b/src/Main.java
--- a/src/Main.java	(revision 2cb12ad41317acdf442dae3ac5e4c279f041e10e)
+++ b/src/Main.java	(date 1618942693511)
@@ -19,7 +19,6 @@
     private static final int TIME_STEP = 100;
 
     public static void main(String[] args) {
-
         //call for preset values or not user selected values for each warrior class
         Battle battle = new Battle();
         BattleGUI battleGUI = new BattleGUI();
Index: src/results.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>182, axis, 5, 2, 0\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/results.txt b/src/results.txt
--- a/src/results.txt	(revision 2cb12ad41317acdf442dae3ac5e4c279f041e10e)
+++ b/src/results.txt	(date 1618944650582)
@@ -1,1 +1,11 @@
 182, axis, 5, 2, 0
+388, axis, 12, 5, 0
+207, allies, 14, 5, 2
+192, axis, 26, 4, 5
+323, axis, 12, 5, 0
+202, allies, 20, 4, 5
+178, axis, 17, 5, 2
+221, axis, 15, 5, 2
+297, allies, 3, 4, 2
+254, axis, 15, 5, 0
+182, axis, 29, 4, 5
